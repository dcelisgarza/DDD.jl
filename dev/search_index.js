var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions-1","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/#Dislocation-1","page":"Functions","title":"Dislocation","text":"","category":"section"},{"location":"functions/#Segment-Forces-1","page":"Functions","title":"Segment Forces","text":"","category":"section"},{"location":"functions/#","page":"Functions","title":"Functions","text":"calcSelfForce\n\ncalcSegSegForce\n\ncalcSegForce","category":"page"},{"location":"functions/#DDD.calcSelfForce","page":"Functions","title":"DDD.calcSelfForce","text":"calcSelfForce(\n    dlnParams::DislocationP,\n    matParams::MaterialP,\n    network::DislocationNetwork,\n)\n\nCalculates the self-interaction force felt by two nodes in a segment. Naturally the forces are equal and opposite to each other.\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.calcSegSegForce","page":"Functions","title":"DDD.calcSegSegForce","text":"!!! Note     This function is based on the SegSegForces function by A. Arsenlis et al. It is optimised for speed and reusability. It has also been locally parallelised.\n\n\n\nIt implements the analytical solution of the force between two dislocation segments. Details are found in Appendix A.1. in \"Enabling Strain Hardening Simulations with Dislocation Dynamics\" by A. Arsenlis et al.\n\nAt a high level this works by creating a local coordinate frame using the line directions of the dislocation segments and a vector orthogonal to them. The line integrals are then evaluated parametrically utilising this local coordinate. BibTex citation here:\n\n@article{Arsenlis_2007, \tdoi = {10.1088/0965-0393/15/6/001}, \turl = {https://doi.org/10.1088%2F0965-0393%2F15%2F6%2F001}, \tyear = 2007, \tmonth = {jul}, \tpublisher = {{IOP} Publishing}, \tvolume = {15}, \tnumber = {6}, \tpages = {553–595}, \tauthor = {A Arsenlis and W Cai and M Tang and M Rhee and T Oppelstrup and G Hommes and T G Pierce and V V Bulatov}, \ttitle = {Enabling strain hardening simulations with dislocation dynamics}, \tjournal = {Modelling and Simulation in Materials Science and Engineering}, \tabstract = {Numerical algorithms for discrete dislocation dynamics simulations are investigated for the purpose of enabling strain hardening simulations of single crystals on massively parallel computers. The algorithms investigated include the calculation of forces, the equations of motion, time integration, adaptive mesh refinement, the treatment of dislocation core reactions and the dynamic distribution of data and work on parallel computers. A simulation integrating all these algorithmic elements using the Parallel Dislocation Simulator (ParaDiS) code is performed to understand their behaviour in concert and to evaluate the overall numerical performance of dislocation dynamics simulations and their ability to accumulate percent of plastic strain.} }\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.calcSegForce","page":"Functions","title":"DDD.calcSegForce","text":"calcSegForce(\n    dlnParams::DislocationP,\n    matParams::MaterialP,\n    network::DislocationNetwork;\n    # mesh::RegularCuboidMesh,\n    # dlnFEM::DislocationFEMCorrective;\n    parallel::Bool = true,\n)\n\n\n\n\n\n","category":"function"},{"location":"functions/#Dislocation-Topology-1","page":"Functions","title":"Dislocation Topology","text":"","category":"section"},{"location":"functions/#","page":"Functions","title":"Functions","text":"removeNode!\n\nremoveConnection!\n\nremoveLink!\n\nremoveUpdate\n\nmergeNode!","category":"page"},{"location":"functions/#DDD.removeNode!","page":"Functions","title":"DDD.removeNode!","text":"removeNode!(network::DislocationNetwork, nodeGone::Int, lastNode = nothing)\n\nIn-place remove nodeGone. If nodeGone is not the last node, this replaces the entries corresponding to nodeGone with lastNode. Else it simply zeros out the entries corresponding to lastNode. This also decreases numNode by one. If lastNode is nothing, this function finds it.\n\nModifies\n\nnetwork.links\nnetwork.coord\nnetwork.label\nnetwork.nodeVel\nnetwork.numNode\nnetwork.connectivity\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.mergeNode!","page":"Functions","title":"DDD.mergeNode!","text":"mergeNode!(network::DislocationNetwork, nodeKept::Int, nodeGone::Int)\n\nMerges nodeGone into nodeKept. After calling this function there are no repeated entries, self-links or double links.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FEM-1","page":"Functions","title":"FEM","text":"","category":"section"},{"location":"functions/#","page":"Functions","title":"Functions","text":"shapeFunction\n\nshapeFunctionDeriv","category":"page"},{"location":"functions/#DDD.shapeFunction","page":"Functions","title":"DDD.shapeFunction","text":"shapeFunction(shape<:AbstractShapeFunction, x, y, z)\n\nReturns the shape functions of type typeof(shape) <: AbstractShapeFunction. If x,y,z are floats returns a vector of length N, different shape functons have different numbers of nodes. If given vectors, returns an array of size (N, length(x)).\n\nnote: Note\nAll coordinate vectors must be of equal length.\n\nshapeFunctionDeriv are the 1st order derivatives of the shape functions.\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.shapeFunctionDeriv","page":"Functions","title":"DDD.shapeFunctionDeriv","text":"shapeFunctionDeriv(shape<:AbstractShapeFunction, x, y, z)\n\nReturns the first order derivative of the shape functions, shapeFunction, of type typeof(shape) <: AbstractShapeFunction. If x,y,z are floats returns a 2D array of size (N, 3). If given vectors, returns a 3D array of size (N, 3, length(x)).\n\nnote: Note\nAll coordinate vectors must be of equal length.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Dislocation-FEM-Coupling-1","page":"Functions","title":"Dislocation FEM Coupling","text":"","category":"section"},{"location":"functions/#","page":"Functions","title":"Functions","text":"calcPKForce\n\ncalc_σ_hat","category":"page"},{"location":"functions/#Miscelaneous-1","page":"Functions","title":"Miscelaneous","text":"","category":"section"},{"location":"functions/#","page":"Functions","title":"Functions","text":"makeInstanceDict\n\ntranslateEnum\n\nsubTypeTree\n\nmakeTypeDict\n\ninclusiveComparison\n\ncompStruct\n\nintAngle\n\nextAngle\n\nrot3D\n\ndimDot\n\ndimNorm","category":"page"},{"location":"functions/#DDD.makeInstanceDict","page":"Functions","title":"DDD.makeInstanceDict","text":"makeInstanceDict(valType::DataType)\n\nMake a dictionary of enumerated variable instances. Helps in translating JSON files.\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.makeTypeDict","page":"Functions","title":"DDD.makeTypeDict","text":"makeTypeDict(valType::DataType)\n\nInputs contain strings that correspond to DDD data types. This function atuomatically creates a dictionary for all concrete subtypes of a given valType.\n\nExamples\n\njulia> abstract type MyAbstractType end\njulia> struct MyStruct1 <: MyAbstractType end\njulia> struct MyStruct2 <: MyAbstractType end\njulia> makeTypeDict(MyAbstractType)\nDict{String,Any} with 4 entries:\n  \"DDD.MyStruct1()\" => MyStruct1()\n  \"DDD.MyStruct2()\" => MyStruct2()\n  \"MyStruct1()\"     => MyStruct1()\n  \"MyStruct2()\"     => MyStruct2()\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.inclusiveComparison","page":"Functions","title":"DDD.inclusiveComparison","text":"inclusiveComparison(data, args...)::Bool\n\nCompare data to a tuple, return true if it is equal to any arg, false if it is not equal to any.\n\nExamples\n\njulia> inclusiveComparison(\"f\", 1,4,5,\"f\")\ntrue\njulia> inclusiveComparison(23.246, 1.5, 4, 5, \"f\")\nfalse\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.compStruct","page":"Functions","title":"DDD.compStruct","text":"compStruct(arg1, arg2; verbose::Bool = false)\n\nFunction that compares values of the fields of two variables arg1 and arg2 with the same structure. If verbose = true, it will print which fields are different from each other.\n\nExamples\n\njulia> struct MyStruct1; x; end\njulia> test1 = MyStruct1(1)\nMyStruct1(1)\njulia> test2 = MyStruct1(5)\nMyStruct1(5)\njulia> compStruct(test1, test2; verbose = true)\nStructures differ in field: x.\nfalse\njulia> compStruct(1, 1; verbose = true)\ntrue\njulia> compStruct(1, [1]; verbose = true)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.intAngle","page":"Functions","title":"DDD.intAngle","text":"intAngle(n::Int)\n\nCalculates the interior angle of a regular polygon with n sides.\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.extAngle","page":"Functions","title":"DDD.extAngle","text":"extAngle(n::Int)\n\nCalculates the exterior angle of a regular polygon with n sides.\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.rot3D","page":"Functions","title":"DDD.rot3D","text":"rot3D(\n    xyz::AbstractVector{T1},\n    uvw::AbstractVector{T2},\n    abc::AbstractVector{T3},\n    θ::T4,\n) where {T1, T2, T3, T4}\n\nRotate point xyz about the line with direction vector uvw that crosses the point abc by the angle θ. Further details found here.\n\nExamples\n\njulia> rot3D([1;1;1],[1;0;0],[0;0;0],π/2)\n3-element Array{Float64,1}:\n  1.0\n -0.9999999999999999\n  1.0\njulia> rot3D([1;1;1],[1;0;0],[0;0;0],-π/2)\n3-element Array{Float64,1}:\n1.0\n1.0\n-0.9999999999999999\njulia> rot3D([1;1;1],[1;0;0],[0;0;0],π)\n3-element Array{Float64,1}:\n  1.0\n -1.0000000000000002\n -0.9999999999999999\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.dimDot","page":"Functions","title":"DDD.dimDot","text":"dimDot(\n    x::AbstractArray{T1, N},\n    y::AbstractArray{T2, N};\n    dim::Int = 2,\n) where {T1, T2, N}\n\nPerform dot product along dimension dim of an array, returns a vector of dot products.\n\n\n\n\n\n","category":"function"},{"location":"functions/#DDD.dimNorm","page":"Functions","title":"DDD.dimNorm","text":"dimNorm(x::AbstractArray{T, N}; dim::Int = 2) where {T, N}\n\nCalculate norms along dimension dim of an array, returns a vector of norms.\n\n\n\n\n\n","category":"function"},{"location":"theory/#Discrete-Dislocation-Dynamics-1","page":"Discrete Dislocation Dynamics","title":"Discrete Dislocation Dynamics","text":"","category":"section"},{"location":"postProcessing/#Post-Processing-1","page":"Post Processing","title":"Post Processing","text":"","category":"section"},{"location":"postProcessing/#","page":"Post Processing","title":"Post Processing","text":"plotNodes\n\nplotNodes!","category":"page"},{"location":"postProcessing/#DDD.plotNodes","page":"Post Processing","title":"DDD.plotNodes","text":"plotNodes(obj::Union{DislocationLoop, DislocationNetwork}, args...; kw...)\n\nPlots dislocation network as nodes connected by segments. Returns a new figure. See plotNodes! for mutating version.\n\n\n\n\n\n","category":"function"},{"location":"postProcessing/#DDD.plotNodes!","page":"Post Processing","title":"DDD.plotNodes!","text":"plotNodes!(fig, obj::Union{DislocationLoop, DislocationNetwork}, args...; kw...)\n\nUpdates figure to plot dislocation network as nodes connected by segments. See plotNodes for non-mutating version.\n\n\n\n\n\n","category":"function"},{"location":"Dislocations/#Dislocation-Generation-1","page":"Dislocations","title":"Dislocation Generation","text":"","category":"section"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Dislocations are described, generated and validated by custom types, structures and functions. By subtyping the provided types with new concrete types, users can define functions which dispatch specifically on their new types while minimising the need for code rewrites, as multiple dispatch takes care of everything during JIT compilation. Structures have not had their default constructors overwritten, we provide custom constructors whose use is recommended instead.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"In discrete dislocation dynamics, dislocations are described by nodes connected by segments. The nodes are labelled according to their type, which is used by the software to decide how they are treated. However, labels are discrete variables, so they cannot take on any value. Additionally, accidentally using non-existent node types may produce silent and difficult to track errors. It is also impractical to validate node types at runtime. We solve these issues by defining a custom enumerated type, which not only limits possible values but informs users and developers of what the values represent.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"nodeType","category":"page"},{"location":"Dislocations/#DDD.nodeType","page":"Dislocations","title":"DDD.nodeType","text":"@enum nodeType begin\n    none = 0    # Undefined node, value at initialisation.\n    intMob = 1  # Internal mobile node.\n    intFix = 2  # Internal fixed node.\n    srfMob = 3  # Mobile surface node.\n    srfFix = 4  # Fixed surface node.\n    ext = 5     # External node.\nend\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Of course, mislabelling a node with an erroneous but defined value may still occur. Preventing such bugs is the task of users and developers, however the problem may is eased by the self-descriptive nature of enumerated types.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Dislocations also have different idealised segment types which are characterised by the relationship between the line direction and Burgers vector. These idealised types are used in the code for in loop generation. We've defined a few common types, most of which are not currently used but may prove useful in the future, for example in the statistical analysis of the dislocation network.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"AbstractDlnSeg","category":"page"},{"location":"Dislocations/#DDD.AbstractDlnSeg","page":"Dislocations","title":"DDD.AbstractDlnSeg","text":"abstract type AbstractDlnSeg end\nstruct segNone <: AbstractDlnSeg end    # Undefined segment\nstruct segEdge <: AbstractDlnSeg end    # Edge segment\nstruct segEdgeN <: AbstractDlnSeg end   # Edge segment\nstruct segScrew <: AbstractDlnSeg end   # Screw segment\nstruct segMixed <: AbstractDlnSeg end   # Mixed segment\n\nwhere segEdge have (bmb perp bmt) perp bmn, segEdgeN have (bmb perp bmt) parallel bmn, segScrew have bmb parallel bmt, segMixed have bmb notperp bmt  bmb notperp bmn and bmb is the Burgers vector and bmn the slip plane.\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Dislocation loops are idealised as having different classifications. Prismatic loops are made up only of edge segments generally with the same slip system; shear loops are made up of a mixture of segment types with the same slip system; jogs and kinks are steps not contained in the slip plane. These idealisations can be used to automate loop generation with minimal rewriting via multiple dispatch. We provide the following types for such a purpose.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"AbstractDlnStr","category":"page"},{"location":"Dislocations/#DDD.AbstractDlnStr","page":"Dislocations","title":"DDD.AbstractDlnStr","text":"abstract type AbstractDlnStr end\nstruct loopDln <: AbstractDlnStr end    # Unclassified loop\nstruct loopPrism <: AbstractDlnStr end  # Prismatic loop\nstruct loopShear <: AbstractDlnStr end  # Shear loop\nstruct loopJog <: AbstractDlnStr end    # Jog\nstruct loopKink <: AbstractDlnStr end   # Kink\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Generating dislocation networks often involves distributing the initial loops within the simulation domain in a particular way. We again define custom structures that enable us to make use of multiple dispatch.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"AbstractDistribution","category":"page"},{"location":"Dislocations/#DDD.AbstractDistribution","page":"Dislocations","title":"DDD.AbstractDistribution","text":"abstract type AbstractDistribution end\nstruct Zeros <: AbstractDistribution end\nstruct Rand <: AbstractDistribution end\nstruct Randn <: AbstractDistribution end\nstruct Regular <: AbstractDistribution end\n\nDistributions for dislocation sources.\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Mobility functions describe how dislocations move within a material. There are many variations of such functions and users may want/need to use different functions for different purposes. Creating concrete mobility types lets users define a function for their new concrete mobility type and carry on with their lives.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"AbstractMobility","category":"page"},{"location":"Dislocations/#DDD.AbstractMobility","page":"Dislocations","title":"DDD.AbstractMobility","text":"abstract type AbstractMobility end\nstruct mobBCC <: AbstractMobility end\nstruct mobFCC <: AbstractMobility end\nstruct mobHCP <: AbstractMobility end\n\nMobility functions.\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"As previously mentioned, idealised dislocation segments live on slip systems, which are pairings of slip plane and Burgers vector. These can be stored in the following structure.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"SlipSystem","category":"page"},{"location":"Dislocations/#DDD.SlipSystem","page":"Dislocations","title":"DDD.SlipSystem","text":"struct SlipSystem{T1, T2}\n    crystalStruct::T1   # Crystal structure\n    slipPlane::T2       # Slip plane\n    bVec::T2            # Burgers vector\nend\n\nStructure to store slip systems.\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"As slip systems are defined with respect to pure edge dislocations, we recommended users use the keyword constructor as it validates the orthogonality of paired Burgers vector and slip plane.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"SlipSystem(;\n    crystalStruct::T1,\n    slipPlane::T2,\n    bVec::T2,\n) where {T1 <: AbstractCrystalStruct, T2 <: AbstractArray{T, N} where {T, N}}","category":"page"},{"location":"Dislocations/#DDD.SlipSystem-Union{Tuple{}, Tuple{T2}, Tuple{T1}} where T2<:(AbstractArray{T,N} where N where T) where T1<:AbstractCrystalStruct","page":"Dislocations","title":"DDD.SlipSystem","text":"SlipSystem(;\n    crystalStruct::T1,\n    slipPlane::T2,\n    bVec::T2,\n) where {T1 <: AbstractCrystalStruct, T2 <: AbstractArray{T, N} where {T, N}}\n\nKeyword constructor for SlipSystem. Throws error if bmb notperp bmn where bmb is the Burgers vector and bmn the slip plane.\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"The simulation requires certain parameters pertaining to the dislocation network being modelled. These values control certain aspects of the simulation and are stored in the following structure.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationP","category":"page"},{"location":"Dislocations/#DDD.DislocationP","page":"Dislocations","title":"DDD.DislocationP","text":"struct DislocationP{T1, T2, T3, T4}\n    coreRad::T1         # Core radius\n    coreRadSq::T1       # Square of core radius\n    coreRadMag::T1      # Magnitude of core radius\n    minSegLen::T1       # Minimum segment length\n    maxSegLen::T1       # Maximum segment length\n    minArea::T1         # Minimum area enclosed by 3 segments\n    maxArea::T1         # Maximum area enclosed by 3 segments\n    maxConnect::T2      # Maximum connectivity\n    remesh::T3          # Remesh flag\n    collision::T3       # Collision flag\n    separation::T3      # Separation flag\n    virtualRemesh::T3   # Virtual remeshing flag\n    edgeDrag::T1        # Drag coefficient edge dislocation\n    screwDrag::T1       # Drag coefficient screw dislocation\n    climbDrag::T1       # Drag coefficient climb direction\n    lineDrag::T1        # Drag coefficient line direction\n    mobility::T4        # Mobility law\nend\n\nStructure to store dislocation parameters.\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"We recommend the use of the keyword constructor as it performs sanity checks on various parameters, ensuring a hierarchy of values is maintained.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationP(;\n    coreRad::T1,\n    coreRadMag::T1,\n    minSegLen::T1,\n    maxSegLen::T1,\n    minArea::T1,\n    maxArea::T1,\n    maxConnect::T2,\n    remesh::T3,\n    collision::T3,\n    separation::T3,\n    virtualRemesh::T3,\n    edgeDrag::T1,\n    screwDrag::T1,\n    climbDrag::T1,\n    lineDrag::T1,\n    mobility::T4,\n) where {T1, T2 <: Int, T3 <: Bool, T4 <: AbstractMobility}","category":"page"},{"location":"Dislocations/#DDD.DislocationP-Union{Tuple{}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T4<:AbstractMobility where T3<:Bool where T2<:Int64 where T1","page":"Dislocations","title":"DDD.DislocationP","text":"DislocationP(;\n    coreRad::T1,\n    coreRadMag::T1,\n    minSegLen::T1,\n    maxSegLen::T1,\n    minArea::T1,\n    maxArea::T1,\n    maxConnect::T2,\n    remesh::T3,\n    collision::T3,\n    separation::T3,\n    virtualRemesh::T3,\n    edgeDrag::T1,\n    screwDrag::T1,\n    climbDrag::T1,\n    lineDrag::T1,\n    mobility::T4,\n) where {T1, T2 <: Int, T3 <: Bool, T4 <: AbstractMobility}\n\nKeyword constructor for DislocationP. Validates values and calculates derived quantities.\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Dislocation loops form the basis of a network, we provide a structure to store these loops, whether idealised or otherwise.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationLoop","category":"page"},{"location":"Dislocations/#DDD.DislocationLoop","page":"Dislocations","title":"DDD.DislocationLoop","text":"struct DislocationLoop{T1, T2, T3, T4, T5, T6, T7, T8, T9}\n    loopType::T1    # Loop type\n    numSides::T2    # Number of sides per loop\n    nodeSide::T2    # Number of nodes per side\n    numLoops::T2    # Number of loops to generate\n    segLen::T3      # Segment lengths\n    slipSystem::T4  # Slip system\n    links::T5       # Links matrix\n    slipPlane::T6   # Slip plane for each link\n    bVec::T6        # Burgers vector for each link\n    coord::T6       # Coordinates of each node\n    label::T7       # Label of each node\n    buffer::T8      # Mean distance buffer separating each loop centre\n    range::T6       # Distribution range of generated loops\n    dist::T9        # Distribution of generated loops\nend\n\nStructure to store dislocation loop.\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Again we recommend the use of the key-word only constructor as it provides an interface to call specific constructors which dispatch on loopType and generate the loop automatically. The default constructor should only be used for truly custom loops, however creating a concrete subtype of AbstractDlnStr and a constructor which dispatches on this new type is highly recommended since it facilitates testing, reproducibility and seamlessly integrates with existing infrastructure.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationLoop(;\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}","category":"page"},{"location":"Dislocations/#DDD.DislocationLoop-Union{Tuple{}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T8<:AbstractDistribution where T7<:(AbstractArray{T,N} where N where T) where T6 where T5<:AbstractArray{nodeType,1} where T4<:(AbstractArray{T,N} where N where T) where T3 where T2<:Int64 where T1<:AbstractDlnStr","page":"Dislocations","title":"DDD.DislocationLoop","text":"DislocationLoop(;\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}\n\nGeneric keyword constructor for DislocationLoop. Calls other constructors that dispatch on loopType.\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"The first concrete DislocationLoop constructor is the \"zero\" constructor. The way Julia's multiple dispatch works is by dispatching on the most specific method for the inputs provided. Therefore this constructor will be called whenever the loop type is loopDln().","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationLoop(\n    loopType::T1;\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: loopDln,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}","category":"page"},{"location":"Dislocations/#DDD.DislocationLoop-Union{Tuple{T1}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T8<:AbstractDistribution where T7<:(AbstractArray{T,N} where N where T) where T6 where T5<:AbstractArray{nodeType,1} where T4<:(AbstractArray{T,N} where N where T) where T3 where T2<:Int64 where T1<:loopDln","page":"Dislocations","title":"DDD.DislocationLoop","text":"DislocationLoop(;\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}\n\nGeneric keyword constructor for DislocationLoop. Calls other constructors that dispatch on loopType.\n\n\n\n\n\nDislocationLoop(\n    loopType::T1;\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: loopDln,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}\n\nConstructor for a \"zero\" DislocationLoop.\n\n\n\n\n\nDislocationLoop(\n    loopType::T1;\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}\n\nValidates inputs and generates a DislocationLoop of loopType defined by the arguments.\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"We also provide a catch-all constructor that generates shear or prismatic loops depending on whether loopType is loopShear() or loopPrism(). It acts as a fallback for other loop types but generates prismatic loops. Such behaviour can be overridden by defining new methods which dispatch on more a specific loopType.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationLoop(\n    loopType::T1;\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}","category":"page"},{"location":"Dislocations/#DDD.DislocationLoop-Union{Tuple{T1}, Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T8<:AbstractDistribution where T7<:(AbstractArray{T,N} where N where T) where T6 where T5<:AbstractArray{nodeType,1} where T4<:(AbstractArray{T,N} where N where T) where T3 where T2<:Int64 where T1<:AbstractDlnStr","page":"Dislocations","title":"DDD.DislocationLoop","text":"DislocationLoop(;\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}\n\nGeneric keyword constructor for DislocationLoop. Calls other constructors that dispatch on loopType.\n\n\n\n\n\nDislocationLoop(\n    loopType::T1;\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: loopDln,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}\n\nConstructor for a \"zero\" DislocationLoop.\n\n\n\n\n\nDislocationLoop(\n    loopType::T1;\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int,\n    T3 <: Union{T where {T}, AbstractArray{T, N} where {T, N}},\n    T4 <: AbstractArray{T, N} where {T, N},\n    T5 <: AbstractVector{nodeType},\n    T6,\n    T7 <: AbstractArray{T, N} where {T, N},\n    T8 <: AbstractDistribution,\n}\n\nValidates inputs and generates a DislocationLoop of loopType defined by the arguments.\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"The dislocation loops contain all the data relevant to a single loop. This data is then used to populate a dislocation network, which is a mutable structure because it evolves over time.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationNetwork","category":"page"},{"location":"Dislocations/#DDD.DislocationNetwork","page":"Dislocations","title":"DDD.DislocationNetwork","text":"mutable struct DislocationNetwork{T1, T2, T3, T4, T5, T6}\n    links::T1\n    slipPlane::T2\n    bVec::T2\n    coord::T2\n    label::T3\n    nodeVel::T2\n    numNode::T4         # Number of nodes in network\n    numSeg::T4          # Number of segments in network\n    maxConnect::T4      # Maximum connections per node\n    connectivity::T5    # Connectivity matrix\n    linksConnect::T5    # Links involved in connection\n    segIdx::T5          # Contains segment index and the nodes of the nodes in said link\n    segForce::T6        # Force on each node of each segment\nend\n\nStructure to store dislocation network.\n\n\n\n\n\n","category":"type"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"Again we provide a keyword constructor which performs some sanity checks and loads the data into the structure. This is the constructor to use when loading data from a previously generated network.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationNetwork(;\n    links::T1,\n    slipPlane::T2,\n    bVec::T2,\n    coord::T2,\n    label::T3,\n    nodeVel::T2,\n    numNode::T4 = 0,\n    numSeg::T4 = 0,\n    maxConnect::T4 = 0,\n    connectivity::T5 = zeros(Int, 0, 0),\n    linksConnect::T5 = zeros(Int, 2, 0),\n    segIdx::T5 = zeros(Int, 2, 3),\n    segForce::T6 = zeros(3, 2, 0),\n) where {\n    T1 <: AbstractArray{T, N} where {T, N},\n    T2 <: AbstractArray{T, N} where {T, N},\n    T3 <: AbstractVector{nodeType},\n    T4 <: Int,\n    T5 <: AbstractArray{Int, N} where {N},\n    T6 <: AbstractArray{T, N} where {T, N},\n}","category":"page"},{"location":"Dislocations/#DDD.DislocationNetwork-Union{Tuple{}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}} where T6<:(AbstractArray{T,N} where N where T) where T5<:(AbstractArray{Int64,N} where N) where T4<:Int64 where T3<:AbstractArray{nodeType,1} where T2<:(AbstractArray{T,N} where N where T) where T1<:(AbstractArray{T,N} where N where T)","page":"Dislocations","title":"DDD.DislocationNetwork","text":"DislocationNetwork(;\n    links::T1,\n    slipPlane::T2,\n    bVec::T2,\n    coord::T2,\n    label::T3,\n    nodeVel::T2,\n    numNode::T4 = 0,\n    numSeg::T4 = 0,\n    maxConnect::T4 = 0,\n    connectivity::T5 = zeros(Int, 0, 0),\n    linksConnect::T5 = zeros(Int, 2, 0),\n    segIdx::T5 = zeros(Int, 2, 3),\n    segForce::T6 = zeros(3, 2, 0),\n) where {\n    T1 <: AbstractArray{T, N} where {T, N},\n    T2 <: AbstractArray{T, N} where {T, N},\n    T3 <: AbstractVector{nodeType},\n    T4 <: Int,\n    T5 <: AbstractArray{Int, N} where {N},\n    T6 <: AbstractArray{T, N} where {T, N},\n}\n\nKeyword constructor for DislocationNetwork, performs validations but creates dislocation network as provided.\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"However, if the aim is to generate a new network then use the following constructor.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationNetwork(\n    sources::T1,\n    maxConnect::T2 = 4,\n    args...;\n    memBuffer = nothing,\n    checkConsistency::T3 = true,\n    kw...,\n) where {\n    T1 <: Union{T, AbstractVector{T}} where {T <: DislocationLoop},\n    T2 <: Int,\n    T3 <: Bool,\n}","category":"page"},{"location":"Dislocations/#DDD.DislocationNetwork-Union{Tuple{T1}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,Vararg{Any,N} where N}} where T3<:Bool where T2<:Int64 where T1<:(Union{AbstractArray{T,1}, T} where T<:DislocationLoop)","page":"Dislocations","title":"DDD.DislocationNetwork","text":"DislocationNetwork(\n    sources::T1,\n    maxConnect::T2 = 4,\n    args...;                        # Optional arguments\n    memBuffer = nothing,            # Buffer for memory allocation\n    checkConsistency::T3 = true,    # Check consistency of generated network\n    kw...,                          # Other keyword arguments\n) where {\n    T1 <: Union{T, AbstractVector{T}} where {T <: DislocationLoop},\n    T2 <: Int,\n    T3 <: Bool,\n}\n\nOut of place constructor for DislocationNetwork. Generates a new dislocation network from previously generated sources.\n\nArgument Explanation\n\nargs... are optional arguments that will be passed on to the loopDistribution function which distributes the loops in sources according to the type of their dist variable.\nkw... are optional keyword arguments that will also be passed to loopDistribution.\nmemBuffer is the numerical value for allocating memory in advance, the quantity textrmmemBuffer times N where N is the total number of nodes in sources, will be the initial number of entries allocated in the matrices that keep the network's data, if it is nothing then the number of entries is textrmround(N log_2(N)).\n\n\n\n\n\n","category":"method"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"If adding to an existing network, use the mutating (also called in-place) constructor.","category":"page"},{"location":"Dislocations/#","page":"Dislocations","title":"Dislocations","text":"DislocationNetwork!(\n    network::T1,\n    sources::T2,\n    maxConnect::T3 = 4,\n    args...;\n    checkConsistency::T4 = true,\n    kw...,\n) where {\n    T1 <: DislocationNetwork,\n    T2 <: Union{T, AbstractVector{T}} where {T <: DislocationLoop},\n    T3 <: Int,\n    T4 <: Bool,\n}","category":"page"},{"location":"Dislocations/#DDD.DislocationNetwork!-Union{Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2}, Tuple{T1,T2,T3,Vararg{Any,N} where N}} where T4<:Bool where T3<:Int64 where T2<:(Union{AbstractArray{T,1}, T} where T<:DislocationLoop) where T1<:DislocationNetwork","page":"Dislocations","title":"DDD.DislocationNetwork!","text":"DislocationNetwork!(\n    network::T1,\n    sources::T2,\n    maxConnect::T3 = 4,\n    args...;\n    checkConsistency::T4 = true,\n    kw...,\n) where {\n    T1 <: DislocationNetwork,\n    T2 <: Union{T, AbstractVector{T}} where {T <: DislocationLoop},\n    T3 <: Int,\n    T4 <: Bool,\n}\n\nIn-place constructor for DislocationNetwork. Generates a new dislocation network from already generated sources. If the matrices already in network are not large enough to accommodate the additions from sources, it will automatically allocate textrmround(N log_2(N)) new entries where N is the total number of nodes in sources.\n\n\n\n\n\n","category":"method"},{"location":"idx/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"idx/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"#Using-DDD.jl-1","page":"Home","title":"Using DDD.jl","text":"","category":"section"},{"location":"#Initialisation-1","page":"Home","title":"Initialisation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Before running a simulation we need to initialise the simulation. For this example, we will use the keyword initialisers because they automatically calculate derived quantities, perform input validations, provide default values, and are make for self-documenting code.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Dislocations live in a material, as such we need a few constants that describe it. These are encapsulated in the immutable <sup>1</sup> structure MaterialP. Note that we use unicode to denote variables as per convention written \\mu -> μ and \\nu -> ν. Here we create a basic material.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> materialP = MaterialP(;\n          μ = 1.0,                  # Shear modulus.\n          μMag = 145e3,             # Shear modulus magnitude.\n          ν = 0.28,                 # Poisson ratio.\n          E = 1.0,                  # Young's modulus, MPa.\n          crystalStruct = BCC(),    # Crystal structure.\n          σPN = 0.0                 # Peierls-Nabarro stress for the material.\n        )\nMaterialP{Float64,BCC}(1.0, 145000.0, 0.28, 1.0, 1.3888888888888888, 0.3888888888888889, 0.07957747154594767, 0.039788735772973836, 0.11052426603603843, BCC(), 0.0)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that a few extra constants have been automatically calculated by the constructor. We find what these correspond to using the fieldnames() on the type of materialP, which is MaterialP.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> fieldnames(typeof(materialP))\n(:μ, :μMag, :ν, :E, :σPN, :omνInv, :νomνInv, :μ4π, :μ8π, :μ4πν, :crystalStruct)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Where omνInv = 1/(1-ν), νomνInv = v/(1-ν), μ4π = μ/(4π), μ8π = μ/(8π), μ4πν = μ/[4π(1-ν)]. These precomputed variables are used in various places and are there to avoid recalculating them later.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Our dislocations also have certain constant characteristics that are encapsulated in their own immutable structure, DislocationP. These parameters are somewhat arbitrary as long as they approximately hold certain proportions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> dislocationP = DislocationP(;\n          coreRad = 90.0,       # Dislocation core radius, referred to as a.\n          coreRadMag = 3.2e-4,  # Magnitude of the core radius.\n          minSegLen = 320.0,    # Minimum segment length.\n          maxSegLen = 1600.0,   # Maximum segment length.\n          minArea = 45000.0,    # Minimum allowable area enclosed by two segments.\n          maxArea = 20*45000.0, # Maximum allowable area enclosed by two segments.\n          maxConnect = 4,       # Maximum number of connections a node can have.\n          remesh = true,        # Flag for remeshing.\n          collision = true,     # Flag for collision checking.\n          separation = true,    # Flag for node separation.\n          virtualRemesh = true, # Flag for remeshing virtual nodes.\n          edgeDrag = 1.0,       # Drag coefficient for edge segments.\n          screwDrag = 2.0,      # Drag coefficient for screw segments.\n          climbDrag = 1e10,     # Drag coefficient along the climb direction.\n          lineDrag = 0.0,       # Drag coefficient along the line direction.\n          mobility = mobBCC(),  # Mobility type for mobility function specialisation.\n        )\nDislocationP{Float64,Int64,Bool,mobBCC}(90.0, 8100.0, 0.00032, 320.0, 1600.0, 45000.0, 900000.0, 4, true, true, true, true, 1.0, 2.0, 1.0e10, 0.0, mobBCC())","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The integration parameters are placed into the following mutable structure.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> integrationP = IntegrationP(;\n          dt = 1e3,\n          tmin = 0.0,\n          tmax = 1e10,\n          method = CustomTrapezoid(),\n          abstol = 1e-6,\n          reltol = 1e-6,\n          time = 0.0,\n          step = 0,\n        )\nIntegrationP{Float64,CustomTrapezoid,Int64}(1000.0, 0.0, 1.0e10, CustomTrapezoid(), 1.0e-6, 1.0e-6, 0.0, 0)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"[!WARNING]IntegrationP will undergo revisions. Probably be split into two, or perhaps eliminated completely in order to use/extend the state of the art DifferentialEquations.jl framework.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Within a given material, we have multiple slip systems, which can be loaded into their own immutable structure. Here we only define a single slip system, but we have the capability of adding more by making the slipPlane and bVec arguments n × 3 matrices rather than vectors.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> slipSystems = SlipSystem(;\n          crystalStruct = BCC(),\n          slipPlane = [1.0; 1.0; 1.0],  # Slip plane.\n          bVec = [1.0; -1.0; 0.0]       # Burgers vector.\n       )\nSlipSystem{BCC,Array{Float64,1}}(BCC(), [1.0, 1.0, 1.0], [1.0, -1.0, 0.0])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"[!WARNING]This may change to perform validity checks regarding the relationship between burgers vector and slip plane.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We also need dislocation sources. We make use of Julia's type system to create standard functions for loop generation. We provide a way of easily and quickly generating loops whose segments inhabit the same slip system. However, new DislocationLoop() methods can be made by subtyping AbstractDlnStr, and dispatching on the new type. One may of also course also use the default constructor and build the initial structures manually.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Here we make a regular pentagonal prismatic dislocation loop, and a regular hexagonal prismatic dislocation loop. Note that the segments may be of arbitrary length, but having asymmetric sides may result in a very ugly and irregular dislocations that may be unphysical or may end up remeshing once the simulation gets under way. As such we recommend making the segment lengths symmetric.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> prisPentagon = DislocationLoop(\n          loopPrism();    # Prismatic loop, all segments are edge segments.\n          numSides = 5,   # 5-sided loop.\n          nodeSide = 1,   # One node per side, if 1 nodes will be in the corners.\n          numLoops = 20,  # Number of loops of this type to generate when making a network.\n          segLen = 10 * ones(5),  # Length of each segment between nodes, equal to the number of nodes.\n          slipSystem = 1, # Slip System (assuming slip systems are stored in a file, this is the index).\n          _slipPlane = slipSystems.slipPlane,  # Slip plane of the segments.\n          _bVec = slipSystems.bVec,            # Burgers vector of the segments.\n          label = nodeType[1; 2; 1; 2; 1],    # Node labels, has to be equal to the number of nodes.\n          buffer = 0.0,   # Buffer to increase the dislocation spread.\n          range = Float64[          # Distribution range\n                        -100 100; # xmin, xmax          \n                        -100 100; # ymin, ymax\n                        -100 100  # zmin, zmax\n                      ],\n          dist = Rand(),  # Loop distribution.\n      )\nDislocationLoop{loopPrism,Int64,Array{Float64,1},Int64,Array{Int64,2},Array{Float64,2},Array{nodeType,1},Float64,Rand}(loopPrism(), 5, 1, 20, [10.0, 10.0, 10.0, 10.0, 10.0], 1, [1 2 … 4 5; 2 3 … 5 1], [0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258], [0.7071067811865475 0.7071067811865475 … 0.7071067811865475 0.7071067811865475; -0.7071067811865475 -0.7071067811865475 … -0.7071067811865475 -0.7071067811865475; 0.0 0.0 … 0.0 0.0], [-1.932030909139515 4.820453044614565 … -1.785143053581134 -6.014513813778146; -1.932030909139515 4.820453044614565 … -1.785143053581134 -6.014513813778146; -8.055755266097462 -5.087941102678986 … 8.123251093712414 0.10921054317980072], nodeType[DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob], 0.0, [-100.0 100.0; -100.0 100.0; -100.0 100.0], Rand())\n\njulia> shearHexagon = DislocationLoop(\n          loopShear();    # Shear loop\n          numSides = 6,\n          nodeSide = 3,   # 3 nodes per side, it devides the side into equal segments.\n          numLoops = 20,\n          segLen = 10 * ones(3 * 6) / 3,  # The hexagon's side length is 10, each segment is 10/3.\n          slipSystem = 1,\n          _slipPlane = slipSystems.slipPlane,\n          _bVec = slipSystems.bVec,\n          label = nodeType[1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2; 1; 2],\n          buffer = 0.0,\n          range = Float64[\n                        -100 100;\n                        -100 100;\n                        -100 100\n                      ],\n          dist = Rand(),\n      )\nDislocationLoop{loopShear,Int64,Array{Float64,1},Int64,Array{Int64,2},Array{Float64,2},Array{nodeType,1},Float64,Rand}(loopShear(), 6, 3, 20, [3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335, 3.3333333333333335], 1, [1 2 … 17 18; 2 3 … 18 1], [0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258], [0.7071067811865475 0.7071067811865475 … 0.7071067811865475 0.7071067811865475; -0.7071067811865475 -0.7071067811865475 … -0.7071067811865475 -0.7071067811865475; 0.0 0.0 … 0.0 0.0], [5.443310539518175 6.8041381743977185 … 1.3608276348795458 4.082482904638633; -6.804138174397717 -5.443310539518174 … -6.804138174397715 -8.164965809277255; 1.3608276348795436 -1.3608276348795432\n… 5.443310539518167 4.082482904638622], nodeType[DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix], 0.0, [-100.0 100.0; -100.0 100.0; -100.0 100.0], Rand())","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The dislocation loops will be centred about the origin, but the range, buffer and dist parameters will distribute the dislocations about the simulation domain once the dislocation network is generated. The type of dist must be a concrete subtype of AbstractDistribution and loopDistribution() method should dispatch on this concrete subtype. If a non-suported distribution is required, you only need to create a concrete subtype of AbstractDistribution and a new method of loopDistribution() to dispatch on the new type. This is all the reworking needed, since multiple dispatch will take care of any new distributions when generating the dislocation network.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note also the array of nodeType, this is an enumerated type which ensures node types are limited to only those supported by the model, lowers memory footprint and increases performance.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We can then plot our loops to see our handy work. We use plotlyjs() because it provides a nice interactive experience, but of course, since this is Julia any plotting backend will work. Note that since they have the same slip system but one is a shear and the other a prismatic loop, they are orthogonal to each other.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using Plots\njulia> plotlyjs()\njulia> fig1 = plotNodes(\n          shearHexagon,\n          m = 1,\n          l = 3,\n          linecolor = :blue,\n          markercolor = :blue,\n          legend = false,\n        )\njulia> plotNodes!(fig1, prisPentagon, m = 1, l = 3,\n                  linecolor = :red, markercolor = :red, legend = false)\njulia> plot!(fig1, camera=(100,35), size=(400,400))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: loops)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"After generating our primitive loops, we can create a network using either a vector of dislocation loops or a single dislocation loop. The network may also be created manually, and new constructor methods may be defined for bespoke cases. For our purposes, we use the constructor that dispatches on Union{DislocationLoop, AbstractVector{<:DislocationLoop}}, meaning a single variable whose type is DislocationLoop or a vector of them. Here we use a vector with both our loop structures.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Since the dislocation network is a constantly evolving entity, this necessarily means this is a mutable structure.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> network = DislocationNetwork(\n          [shearHexagon, prisPentagon]; # Dispatch type, bespoke functions dispatch on this.\n          memBuffer = 1 # Buffer for memory allocation.\n       )\n DislocationNetwork{Array{Int64,2},Array{Float64,2},Array{nodeType,1},Int64,Array{Int64,2},Array{Float64,3}}([1 2 … 459 460; 2 3 … 460 456], [0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258; 0.5773502691896258 0.5773502691896258 … 0.5773502691896258 0.5773502691896258], [0.7071067811865475 0.7071067811865475 … 0.7071067811865475 0.7071067811865475; -0.7071067811865475 -0.7071067811865475 … -0.7071067811865475 -0.7071067811865475; 0.0 0.0 … 0.0 0.0], [46.39761283211718 47.75844046699673 … -57.496002894414175 -61.72537365461118; -49.937613036904054 -48.57678540202451 … -59.28380906452193 -63.51317982471895; 41.67317243370178 38.9515171639427 … -2.1285556467706765 -10.14259619730329], nodeType[DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix  …  DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intMob, DDD.intFix, DDD.intMob, DDD.intFix, DDD.intMob], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], 460, 460, 4, [2 2 … 2 2; 1 1 … 458 459; … ; 0 0 … 0 0; 0 0 … 0 0], [1 2 … 2 2; 1 1 … 1 2], [1 1 2; 2 2 3; … ; 459 459 460; 460 460 456],\n [0.0 0.0; 0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0; 0.0 0.0]\n ...\n [0.0 0.0; 0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0; 0.0 0.0]\n [0.0 0.0; 0.0 0.0; 0.0 0.0])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This method automatically takes the previously defined loops and scatters them according to the parameters provided in the DislocationLoop structure. Furthermore, the memBuffer defaults to 10. The number of entries allocated for the matrices is the total number of nodes in the network times memBuffer. Here we allocate enough memory for all the nodes but no more. Since julia is dynamic we can allocate memory when needed. However for performance reasons it is advisable to minimise memory management as much as possible.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This function will also automatically calculate other quantities to keep track of the network's links, nodes and segments.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> fieldnames(typeof(network))\n(:links, :slipPlane, :bVec, :coord, :label, :nodeVel, :numNode, :numSeg, :maxConnect, :connectivity, :linksConnect, :segIdx, :segForce)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We can also view our network with plotNodes.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> fig2 = plotNodes(\n          network,\n          m = 1,\n          l = 3,\n          linecolor = :blue,\n          markercolor = :blue,\n          legend = false,\n        )\njulia> plot!(fig2, camera=(110,40), size=(400,400))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: network)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"<a name=\"1\">1</a>: Immutability is translated into code performance.","category":"page"},{"location":"#IO-1","page":"Home","title":"IO","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The package provides a way to load and save its parameters using JSON files. While this is not the most performant format for IO, it is a popular and portable, web-friendly file format that is very human readable (and therefore easy to manually create). It also produces smaller file sizes both compressed and uncompressed. Which is why it is so popular for online data sharing.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"JSON files are representations of dictionaries with (key, value) pairs, which are analogous to the (key, value) pair of structures. This makes it so any changes to any structure will automatically be taken care of by the JSON library. Arrays are recursively linearised into vectors of vectors using the calling language's preferred storage order. This means arrays preserve their shape and dimensionality regardless of whether the inputting or outputting language stores arrays in column- or row-major order.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"They also have the added advantage of being designed for sending over the web, so they have small compressed and uncompressed file sizes, smaller than BSON, HDF5 and its variants such as MAT and JLD2 formats. They also aren't plagued by the portability issues these other formats have, as well as being generally easier to read, create and work with, while being within a factor of ≈3 of the aforementioned filetypes. They do however, allocate more memory than the others while being created, but the end result is half the size or less of these other file formats.","category":"page"},{"location":"#Sample-JSON-File-1","page":"Home","title":"Sample JSON File","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is a sample JSON file for a dislocation loop. They can be compactified by editors to decrease storage space by removing unnecessary line breaks and spaces. Here we show a somewhat longified view which is very human readable and trivially easy to create manually. Note that arrays are recursively linearised as vectors of vectors, where the linearisation follows the calling language's memory order. This means arrays will keep their shape and dimensionality regardless of the language that opens the JSON file.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"[\n  {\n    \"loopType\": \"DDD.loopPrism()\",\n    \"numSides\": 4,\n    \"nodeSide\": 2,\n    \"numLoops\": 1,\n    \"segLen\": [1, 1, 1, 1, 1, 1, 1, 1],\n    \"slipSystem\": 1,\n    \"label\": [2, 1, 2, 1, 2, 1, 2, 1],\n    \"buffer\": 0,\n    \"range\": [[0, 0, 0], [0, 0, 0]],\n    \"dist\": \"DDD.Zeros()\"\n  }\n]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This file describes an array, denoted by the [] at the top and bottom of the file, of a structure denoted by the {} on the second and penultimate lines. We could remove the [] but having all files be represent arrays (even if they are of length 1) simplifies users' and developers' lives by letting the same IO functions work for every case.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The keys are on the left side of the colon and the values on the right. This would get loaded to a dictionary with the same (key, value) pair shown here. Since the keys are the structure's field names and the values their value, everything can be easily matched to the constructor function.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Also, with since JSON files represent dictionaries, users can add irrelevant data to the file either as extra entries to the top level array, or into the structure definition without breaking their ability to use the file.","category":"page"},{"location":"#Initialisation,-Data-Dump,-and-Reloading-1","page":"Home","title":"Initialisation, Data Dump, and Reloading","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"One can load all their parameters at once like so.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"fileDislocationP = \"../inputs/simParams/sampleDislocationP.JSON\"\nfileMaterialP = \"../inputs/simParams/sampleMaterialP.JSON\"\nfileIntegrationP = \"../inputs/simParams/sampleIntegrationP.JSON\"\nfileSlipSystem = \"../data/slipSystems/SlipSystems.JSON\"\nfileDislocationLoop = \"../inputs/dln/samplePrismShear.JSON\"\ndlnParams, matParams, intParams, slipSystems, dislocationLoop = loadParams(\n    fileDislocationP,\n    fileMaterialP,\n    fileIntegrationP,\n    fileSlipSystem,\n    fileDislocationLoop,\n)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"which not only loads the data but returns the aforementioned structures. If there is a single file holding all the parameters, then all the filenames would be the same, but nothing else would change as the file would be loaded into a large dictionary and only the relevant (key, value) pairs are used in each case.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Users may also load individual structures as follows.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"dictDislocationP = load(fileDislocationP)\ndislocationP = loadDislocationP(dictDislocationP[1])\n\ndictMaterialP = load(fileMaterialP)\nmaterialP = loadMaterialP(dictMaterialP[1])\n\ndictIntegrationP = load(fileIntegrationP)\nintegrationP = loadIntegrationP(dictIntegrationP[1])\n\ndictSlipSystem = load(fileSlipSystem)\nslipSystems = loadSlipSystem(dictSlipSystem[1])\n\n# There can be multiple dislocation types per simulation.\ndictDislocationLoop = load(fileDislocationLoop)\ndislocationLoop = zeros(DislocationLoop, length(dictDislocationLoop))\nfor i in eachindex(dislocationLoop)\n    dislocationLoop[i] = loadDislocationLoop(dictDislocationLoop[i], slipSystems)\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The reason why all the dictionary arguments of the load<struct_name> all have an index is that the files specify an array, as that keeps all files consistent with each other, particularly when saving more than one variable or constant in a single file. Individually loading files like this is useful when recovering previous save states where the data was dumped into a single file, as shown here.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# Dump simulation parameters into a single file. Creates an array where each entry is one of the structs.\nparamDump = \"../outputs/simParams/sampleDump.JSON\"\nsave(paramDump, dlnParams, matParams, intParams, slipSystems, dislocationLoop)\n\n# Dump network data into a separate file.\nnetworkDump = \"../outputs/dln/sampleNetwork.JSON\"\nsave(networkDump, network)\n\n# Reload parameters.\nsimulation = load(paramDump)\ndlnParams2 = loadDislocationP(simulation[1])\nmatParams2 = loadMaterialP(simulation[2])\nintParams2 = loadIntegrationP(simulation[3])\nslipSystems2 = loadSlipSystem(simulation[4])\ndislocationLoop2 = zeros(DislocationLoop, length(simulation[5]))\nfor i in eachindex(dislocationLoop2)\n    dislocationLoop2[i] = loadDislocationLoop(simulation[5][i], slipSystems2)\nend\n\n# Reload network.\nnetwork2 = loadNetwork(networkDump)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The reason why loadNetwork() is different from the others is that the other values are constants, so for record keeping they would only need to be saved once per simulation. The network might have to be saved at multiple times so it gets a simpler function that calls load() internally.","category":"page"},{"location":"#Against-the-Unbridled-Pursuit-of-Performance-1","page":"Home","title":"Against the Unbridled Pursuit of Performance","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"For the sake of open, reproducible and portable science it is recommended users utilise JSON or a standard delimited file format for their IO. If IO is a performance bottleneck these are some incremental steps one should take to improve it before creating a custom IO format. Beware that your mileage may vary when using other IO formats, some may not be fully mature yet others may be abandoned in favour of better implementations.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Use buffered IO.\nUse Julia's in-built task and asyncronous functionality via tasks and async for either multiple IO streams or an asyncronous IO process while the other threads/cores carry on with the simulation.\nUse BSON, JSON's binary counterpart, though this may break compatibility with other systems, particularly those with different word size and architecture. Furthermore, the binary nature of BSON may be used to inject code into a programme so should only be used for self-generated files.\nUse JLD2. Though the package currently says it has remained largely untested in the wild.\nUse DelimitedFiles.\nUse binary streams.\nUse Parquet\nCreate your own format and IO stream.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"TO BE WRITTEN: HOW TO EXTEND METHODS TO EXPAND FUNCTIONALITY","category":"page"},{"location":"#TODO-1","page":"Home","title":"TODO","text":"","category":"section"},{"location":"#Working-Objectives-1","page":"Home","title":"Working Objectives","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"[x] IO\n[x] Input validation\n[ ] Sensible input generators\n[ ] Performance\n[ ] Compression\n[ ] Asyncronicity\n[ ] Topology functions\n[ ] Internal Remeshing\n[ ] Coarsen mesh\n[x] Merge nodes\n[ ] Test all edge cases\n[ ] Refine mesh\n[x] Split nodes\n[ ] Surface remeshing\n[ ] Virtual node remeshing\n[x] Self-segment force\n[x] Seg-seg force\n[ ] Test tiny segment edge case\n[ ] Distributed and gpu parallelisation\n[ ] PK force\n[x] Implementation\n[ ] Tests\n[ ] Post processing\n[x] Plot nodes\n[ ] Asyncronicity\n[ ] Plot recipe\n[ ] Statistical analysis\n[ ] Mobility function\n[ ] BCC\n[ ] FCC\n[ ] Integration\n[ ] Refactor integrator structures\n[ ] Look into using DifferentialEquations.jl for structure and perhaps use/extension of methods\n[ ] Make integrator\n[ ] Couple to FEM, perhaps use a package from JuliaFEM.\n[ ] Mesh and FE matrices generation\n[ ] Boundary conditions\n[ ] Neuman\n[ ] Dirichlet\n[ ] Displacements\n[ ] Parallelisation\n[ ] Tractions\n[ ] Parallelisation","category":"page"},{"location":"#Tentative-Objectives-1","page":"Home","title":"Tentative Objectives","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"[ ] Custom 3-vec type, place x,y,z coordinates in contiguous memory instead of columns, ie [x1 y1 z1; x2 y2 z2] -> [x1;y1;z1;x2;y2;z2], have to define custom array type, getindex(arr, (a,b)) = arr[3*(a-1)+b], out of bounds and all the rest. Watch this.\n[ ] Keep an eye on JuliaIO, JuliaFEM, SciML because their methods might be useful.","category":"page"},{"location":"io/#IO-1","page":"IO","title":"IO","text":"","category":"section"},{"location":"io/#Input-1","page":"IO","title":"Input","text":"","category":"section"},{"location":"io/#","page":"IO","title":"IO","text":"load(filename::AbstractString)\n\nloadDislocationLoop(\n    dict::Dict{T1, T2} where {T1, T2},\n    slipSystem::SlipSystem,\n)\n\nloadMaterialP(dict::Dict{T1, T2}) where {T1, T2}\n\nloadIntegrationP(dict::Dict{T1, T2}) where {T1, T2}\n\nloadSlipSystem(dict::Dict{T1, T2}) where {T1, T2}\n\nloadDislocationP(dict::Dict{T1, T2}) where {T1, T2}\n\nloadParams(\n    fileDislocationP::AbstractString,\n    fileMaterialP::AbstractString,\n    fileIntegrationP::AbstractString,\n    fileSlipSystem::AbstractString,\n    fileDislocationLoop::AbstractString,\n)\n\nloadNetwork(fileDislocationNetwork::AbstractString)","category":"page"},{"location":"io/#DDD.load-Tuple{AbstractString}","page":"IO","title":"DDD.load","text":"load(filename::AbstractString)\n\nWrapper for JSON.parsefile(filename).\n\n\n\n\n\n","category":"method"},{"location":"io/#DDD.loadDislocationLoop-Tuple{Dict{T1,T2} where T2 where T1,SlipSystem}","page":"IO","title":"DDD.loadDislocationLoop","text":"function loadDislocationLoop(\n    dict::Dict{T1, T2} where {T1, T2},\n    slipSystem::SlipSystem,\n)\n\nLoads initial dislocation structure out of a dictionary loaded from a JSON file. Returns a variable of type DislocationLoop.\n\n\n\n\n\n","category":"method"},{"location":"io/#DDD.loadMaterialP-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"IO","title":"DDD.loadMaterialP","text":"loadMaterialP(dict::Dict{T1, T2}) where {T1, T2}\n\nLoads material parameters out of a dictionary loaded from a JSON file. Returns a variable of type MaterialP.\n\n\n\n\n\n","category":"method"},{"location":"io/#DDD.loadIntegrationP-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"IO","title":"DDD.loadIntegrationP","text":"loadIntegrationP(dict::Dict{T1, T2}) where {T1, T2}\n\nLoads integration parameters out of a dictionary loaded from a JSON file. Returns a variable of type IntegrationP.\n\n\n\n\n\n","category":"method"},{"location":"io/#DDD.loadSlipSystem-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"IO","title":"DDD.loadSlipSystem","text":"loadSlipSystem(dict::Dict{T1, T2}) where {T1, T2}\n\nLoads slip systems out of a dictionary loaded from a JSON file. Returns a variable of type SlipSystem.\n\n\n\n\n\n","category":"method"},{"location":"io/#DDD.loadDislocationP-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"IO","title":"DDD.loadDislocationP","text":"loadDislocationP(dict::Dict{T1, T2}) where {T1, T2}\n\nLoads dislocation parameters out of a dictionary loaded from a JSON file. Returns a variable of type DislocationP.\n\n\n\n\n\n","category":"method"},{"location":"io/#DDD.loadParams-NTuple{5,AbstractString}","page":"IO","title":"DDD.loadParams","text":"loadParams(\n    fileDislocationP::AbstractString,\n    fileMaterialP::AbstractString,\n    fileIntegrationP::AbstractString,\n    fileSlipSystem::AbstractString,\n    fileDislocationLoop::AbstractString,\n)\n\nLoads simulation parameters out of a dictionary loaded from a JSON file. Returns a tuple of variable types (DislocationP, MaterialP, IntegrationP, SlipSystem, DislocationLoop) or vectors of those types.\n\n\n\n\n\n","category":"method"},{"location":"io/#DDD.loadNetwork-Tuple{AbstractString}","page":"IO","title":"DDD.loadNetwork","text":"loadNetwork(fileDislocationNetwork::AbstractString)\n\nLoads a dislocation network from a JSON file. Returns a DislocationNetwork.\n\n\n\n\n\n","category":"method"},{"location":"io/#Output-1","page":"IO","title":"Output","text":"","category":"section"},{"location":"io/#","page":"IO","title":"IO","text":"save(filename::AbstractString, args...; mode::AbstractString = \"w\")","category":"page"},{"location":"io/#DDD.save-Tuple{AbstractString,Vararg{Any,N} where N}","page":"IO","title":"DDD.save","text":"save(filename::AbstractString, args...; mode::AbstractString = \"w\")\n\nWrapper for JSON.print to a file, args are the variables or structures you want to save.\n\n\n\n\n\n","category":"method"},{"location":"motivation/#Motivation-1","page":"Motivation","title":"Motivation","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"DDD.jl was created with the aim to make 3D discrete dislocation dynamics research more tractable, transparent and productive.","category":"page"},{"location":"motivation/#Objectives-1","page":"Motivation","title":"Objectives","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Dislocation dynamics is notoriously impenetrable due to the wide range of techniques and historically disparate sciences involved in their study. Lowering the barrier to entry and simplifying the workflows of experimental, theoretical and computational researchers will simplify the development of the field. Specifically, our objectives are to develop a codebase that meets the following requirements:","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"ease of use\nsimulations are easy to set up\ninteractivity\nplotting and post-processing\ndata analysis\nautomatic error checking\nstop and restart capabilities\nease of development and maintenance\nreadable code\nmetaprogramming\nmacros (compile time execution)\ngenerated functions (custom functions generated by the code itself)\nproblem logging\nclear warnings, errors and debug information\neasy to add new validations\nhigh level abstractions\narray and matrix operations\nunicode support\ncode introspection\ninteractive debugger\nprofiling and benchmarking\nidentify bottlenecks, type instabilities before runtime\nminimal rewriting\nmodular\ngeneric functions\nself-containment\neasily parallelisable\nlocal parallelisation\ndistributed parallelisation\nGPU parallelisation\nwell documented\neasily add documentation\nnative LaTeX support\nautomatically generated\nwell developed testing capabilities\neasily add tests\neasily interpreted tests\ntest everything even logging events such as warnings and errors\nperformant\nuse as few languages as possible\nCUDA may be needed for specialised parallelisation but should not be a requirement\nself-contained\nno external dependencies\nopen-source, shareable, portable\npublically hosted\nstandardised IO (input-output)\nplug and play","category":"page"},{"location":"motivation/#Possible-Languages-for-Implementation-1","page":"Motivation","title":"Possible Languages for Implementation","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Historically, two languages that have reigned supreme in the field of scientific computing Fortran and C, however with the advent of object-oriented programming, and interpreted languages that list has expanded. Here we offer some likely candidates to build our code. Some of which have been used in the past to create dislocation dynamics codes of different ilks.","category":"page"},{"location":"motivation/#Fortran-(f90)-1","page":"Motivation","title":"Fortran (f90+)","text":"","category":"section"},{"location":"motivation/#Advantages-1","page":"Motivation","title":"Advantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It is performant, readable, modular, open-source, highly abstracted, natively parallelisable (compiler dependent), and safe through the use of intent() inside functions. Documentation for the language itself is available on the f90 standard practices site and there is a sizeable knowledge base found in StackExchange and the Intel Fortran forums.","category":"page"},{"location":"motivation/#Disadvantages-1","page":"Motivation","title":"Disadvantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It lacks interactivity, metaprogramming (aside from preprocessor macros), and a proper internal standard library. BLAS and LAPACK are as close to a standard library as Fortran gets, but they have to be installed and linked to at compilation time. Furthermore, different compilers break portability, in some cases what is performant code in one compiler is bad code in another. It also has nothing in the way of native testing and documenting, but there are Python tools to do so.","category":"page"},{"location":"motivation/#C-1","page":"Motivation","title":"C","text":"","category":"section"},{"location":"motivation/#Advantages-2","page":"Motivation","title":"Advantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It is performant, small, modular, open-source and compilers are highly standardised. There is no shortage of documentation for C all accross the internet.","category":"page"},{"location":"motivation/#Disadvantages-2","page":"Motivation","title":"Disadvantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"On top of lacking what Fortran also lacks, it has the added wrinkle of pointer arithmetic. Which is famously the cause of most C bugs. The best case scenario for such bugs lead to obvious problems like segmentation faults and NaN values. However, more insidious and opaque bugs are not uncommon in complex code, examples include pointer dereferencing, function side effects and memory leaks. Such bugs are hard to track, reproduce and at times catastrophic. Some very well-known bugs and exploits in commercial software such as Windows have been thanks to memory leaks and pointer dereferencing, often going undiscovered for years and through multiple versions. C also doesn't offer anything in the way of abstraction other than structures.","category":"page"},{"location":"motivation/#C-2","page":"Motivation","title":"C++","text":"","category":"section"},{"location":"motivation/#Advantages-3","page":"Motivation","title":"Advantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It has an extensive standard library of optimised algorithms and data structures, all of which are excellently documented. It is open-source and its compilers are also highly standardised (though not as much as C). It also offers serious metaprogramming capabilities, and can be made to be very performant if used correctly, sometimes more so than a naïve C implementation. There are extensive knowledge bases of C++ but the problem is often in deciphering how one may adapt the posted solution to their specific situation.","category":"page"},{"location":"motivation/#Disadvantages-3","page":"Motivation","title":"Disadvantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It is extremely is verbose, very difficult to learn and use correctly, opaque and unintuitive (new v.s. malloc(), del vs free(), namespaces). It mitigates some of the problems of C at the cost of runtime performance and added program complexity. It also tends to make debugging user defined code more difficult because one has to trawl through verbose, complicated syntax. It also requires external libraries to be installed and linked to during compilation.","category":"page"},{"location":"motivation/#Python-1","page":"Motivation","title":"Python","text":"","category":"section"},{"location":"motivation/#Advantages-4","page":"Motivation","title":"Advantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"The golden child of interpreted languages is readable, easy to use, open-source, standardised, portable and interactive. It also has an even more extensive standard library than C++. Its vibrant package ecosystem ensures there are packages for every need and frees the user from worrying about external dependencies because they are taken care of by the package installer either automatically or by printing the command required to install the dependency. It has native documentation, testing and benchmarking capabilities. The language has an extremely high level of abstraction and is rapidly evolving, improving and expanding. Package documentation tends to be the gold standard for documentation across all languages by virtue of the sheer number of users and contributors. There is also an extensive knowledge base throughout the internet where solutions to problems have most likely already been posted about and found, if not, one can make a post and have their question answered rather quickly.","category":"page"},{"location":"motivation/#Disadvantages-4","page":"Motivation","title":"Disadvantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It is not performant without serious modification like using Cython or by standard-breaking practices to use the JIT (just in time compiler) offered by numba. Packages such as numpy and scipy help in this regard, but more often than not, the number crunching is done via calls to C, CUDA and Fortran routines through wrappers or direct external calls. Python can also get somewhat verbose, particularly when using a few packages where namespaces must be distinguished by aliases. Standalone executables are much larger than they would be in other languages.","category":"page"},{"location":"motivation/#Matlab-1","page":"Motivation","title":"Matlab","text":"","category":"section"},{"location":"motivation/#Advantages-5","page":"Motivation","title":"Advantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Is readable, easy to use, standardised and interactive. It has native testing, documentation and benchmarking capabilities. The documentation for in-built functions is excellent. It offers limited object oriented capabilities, usually more than enough.","category":"page"},{"location":"motivation/#Disadvantages-5","page":"Motivation","title":"Disadvantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It is closed-source and proprietary. Worse, many of the toolboxes and specialised features are not standard and require additional purchase. Furthermore, the knowledge base for specific questions is limited to the Mathworks forums where only people with Mathworks accounts may post. Increasingly, Matlab offers less and less in comparison to Python. Pretty much all of the performance issues are shared by both languages, but Python is free, open-source and has a massive community developing packages and adding functionality.","category":"page"},{"location":"motivation/#Julia-1","page":"Motivation","title":"Julia","text":"","category":"section"},{"location":"motivation/#Advantages-6","page":"Motivation","title":"Advantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Every advantage that Python offers is also offered by Julia, from the standard library to benchmarking and testing. Its package ecosystem and user base is nowhere near as large as Python's, but it offers the same functionality.","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Unlike any of the other languages we mentioned, Julia is a JIT (just in time) compiled language, just like Python when using numba. So it offers C and Fortran-like performance after a function has been executed once. It offers the same level of abstraction as Python and Matlab while keeping similar or even equivalent[^1 In most cases, the abstractions have a cost-benefit associated with using them, using introspection tools is recommended if performance is critical. Sometimes they outperform less abstracted implementations, but others a non-abstracted implementation is better.] performance to Fortran and C.","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"One of the advantages of object-oriented code is reusability and expandability. Function dispatch in object-oriented languages depends on the function's class. However, Julia's multiple dispatch, type system, and JIT compilation takes code reusability to another level by letting functions specialise depending on the types of their arguments. This means that one can expand functions defined anywhere in the code by declaring them for new types. This means developers can write generic functions that can be expanded by users as they see fit. A concrete example we use in DDD.jl is in constructing dislocation loops. Where new types of loops or even special dislocation structures don't need their own data structure, one can simply declare a new constructor for a new type of loop and it will be called using the same user-interface.","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Furthermore, Julia can be used as both, a statically typed or dynamically typed language. If one wants performance, one gets performance by annotating types[^2 Types do not have to be known by the user before runtime, they can be given parametrically and the compiler will use the argument's type during runtime to compile a specialised function. This lets programs be generically typed without sacrificing performance or adding verbosity.] and writing well-defined code. If one wants to use Julia interactively like Python or Matlab, that works too. And the compiler will do its best to ensure the code is performant.","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Another aspect that Julia offers that none of the others do is the ability to look at the different stages of compilation. This lets developers and users identify areas where the code might suffer a runtime bottleneck before even running it. There are also extensive profiling, debugging and benchmarking tools that provide timing and memory allocation information. Out of the languages mentioned, Julia is the easiest to write performant code in.","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"If this weren't enough, there is also native support for CPU and GPU parallelisation both local and distributed, as well as the ability to call external languages with a single interface. Its metaprogramming capabilities are on par with C++ but much more concise and less impactful on compilation time.","category":"page"},{"location":"motivation/#Disadvantages-6","page":"Motivation","title":"Disadvantages","text":"","category":"section"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"Multiple dispatch can be abused by new users and may negatively impact performance. Precompilation time for packages and the \"time to first plot\" can be relatively long.","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"It is a new language, things are changing rapidly and backwards compatibility may not always be guaranteed. There are also features that are experimental and subject to change, deprecation and removal. For example, 1.4 CPU parallelisation is experimental as well as the @simd macro for inner loop performance.","category":"page"},{"location":"motivation/#","page":"Motivation","title":"Motivation","text":"A side effect of the incredibly powerful documenting system of Julia is that one can go to where intrinsic functions are implemented and one is free to change them. However this also means that if a user wants to extend an intrinsic method they can use the documentation to navigate to where it is defined and see how it is implemented so they may extend it for their use case.","category":"page"}]
}
