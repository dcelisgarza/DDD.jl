var documenterSearchIndex = {"docs":
[{"location":"theory/#Discrete-Dislocation-Dynamics-1","page":"Discrete Dislocation Dynamics","title":"Discrete Dislocation Dynamics","text":"","category":"section"},{"location":"plotting/#Plotting-1","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"#DDD.jl-1","page":"Index","title":"DDD.jl","text":"","category":"section"},{"location":"#","page":"Index","title":"Index","text":"","category":"page"},{"location":"#","page":"Index","title":"Index","text":"Modules = [DDD]","category":"page"},{"location":"#DDD.AbstractDistribution","page":"Index","title":"DDD.AbstractDistribution","text":"abstract type AbstractDistribution end\nstruct Zeros <: AbstractDistribution end\nstruct Rand <: AbstractDistribution end\nstruct Randn <: AbstractDistribution end\nstruct Regular <: AbstractDistribution end\n\nDistributions for dislocation sources.\n\n\n\n\n\n","category":"type"},{"location":"#DDD.AbstractDlnStr","page":"Index","title":"DDD.AbstractDlnStr","text":"Dislocation structures have different classifications. Prismatic loops are made up only of edge segments with the same slip system; shear loops are made up of a mixture of segment types with the same slip system; jogs and kinks are steps not contained in the slip plane.\n\nabstract type AbstractDlnStr end\nstruct loopDln <: AbstractDlnStr end    # Unclassified loop.\nstruct loopPrism <: AbstractDlnStr end  # Prismatic loop.\nstruct loopShear <: AbstractDlnStr end  # Shear loop.\nstruct loopJog <: AbstractDlnStr end    # Jog.\nstruct loopKink <: AbstractDlnStr end   # Kink.\n\n\n\n\n\n","category":"type"},{"location":"#DDD.DislocationLoop","page":"Index","title":"DDD.DislocationLoop","text":"struct DislocationLoop{\n    T1 <: AbstractDlnStr,\n    T2 <: Int64,\n    T3 <: Union{T where {T <: Float64}, AbstractArray{<:Float64, N} where {N}},\n    T4 <: Union{T where {T <: Int64}, AbstractArray{<:Int64, N} where {N}},\n    T5 <: AbstractArray{<:Int64, N} where {N},\n    T6 <: AbstractArray{<:Float64, N} where {N},\n    T7 <: Vector{<:nodeType},\n    T8 <: Float64,\n    T9 <: AbstractDistribution,\n}\n\n    loopType::T1\n    numSides::T2\n    nodeSide::T2\n    numLoops::T2\n    segLen::T3\n    slipSystem::T4\n    links::T5\n    slipPlane::T6\n    bVec::T6\n    coord::T6\n    label::T7\n    buffer::T8\n    range::T6\n    dist::T9\n\nDislocation loop structure generated via the constructor makeLoop.\n\n\n\n\n\n","category":"type"},{"location":"#DDD.DislocationNetwork","page":"Index","title":"DDD.DislocationNetwork","text":"DislocationNetwork{\n    T1 <: AbstractArray{<:Int64, N} where {N},\n    T2 <: AbstractArray{<:Float64, N} where {N},\n    T3 <: Vector{nodeType},\n    T4 <: Int64,\n    T5 <: Integer,\n}\n    links::T1\n    slipPlane::T2\n    bVec::T2\n    coord::T2\n    label::T3\n    numNode::T4 = 0     # Total number of nodes in network.\n    numSeg::T4 = 0      # Total number of segs in network.\n    maxConnect::T5 = 4  # Maximum connectivity of nodes.\n    connectivity::T1\n    linksConnect::T1\n    segIdx::T1          # segIdx[:,1] is the segment index. Used to find the bVec and slipPlane of a real segment. segIdx[:,2:3] are the indices of the nodes involved in a given link, used to find their coordinates.\n\nDislocation Network structure. See DislocationLoop, makeNetwork and makeNetwork! for further details.\n\n\n\n\n\n","category":"type"},{"location":"#DDD.SlipSystem","page":"Index","title":"DDD.SlipSystem","text":"struct SlipSystem{\n    T1 <: AbstractString,\n    T2 <: AbstractArray{<:Float64, N} where {N},\n}\n    name::T1\n    slipPlane::T2\n    bVec::T2\n\nSlip systems.\n\n\n\n\n\n","category":"type"},{"location":"#DDD.nodeType","page":"Index","title":"DDD.nodeType","text":"Dislocation nodes have labels that change how they are treated by the simulation. There are only given types of nodes so these labels may only take on predefined values and error for anything else.\n\n@enum nodeType begin\n    undef = -1  # Undefined node, value at initialisation.\n    intMob = 0  # Internal mobile node.\n    intFix = 1  # Internal fixed node.\n    srfMob = 2  # Mobile surface node.\n    srfFix = 3  # Fixed surface node.\n    ext = 4     # External node.\nend\n\n\n\n\n\n","category":"type"},{"location":"#DDD.calcSegSegForce-Tuple{DDD.DislocationP,DDD.MaterialP,DislocationNetwork}","page":"Index","title":"DDD.calcSegSegForce","text":"!!! Note     This function is based on the SegSegForces function by A. Arsenlis et al. It is optimised for speed and reusability.\n\n\n\nIt implements the analytical solution of the force between two dislocation segments. Details are found in Appendix A.1. in \"Enabling Strain Hardening Simulations with Dislocation Dynamics\" by A. Arsenlis et al.\n\nAt a high level this works by creating a local coordinate frame using the line directions of the dislocation segments and a vector orthogonal to them. The line integrals are then evaluated parametrically utilising this local coordinate. BibTex citation here:\n\n@article{Arsenlis_2007, \tdoi = {10.1088/0965-0393/15/6/001}, \turl = {https://doi.org/10.1088%2F0965-0393%2F15%2F6%2F001}, \tyear = 2007, \tmonth = {jul}, \tpublisher = {{IOP} Publishing}, \tvolume = {15}, \tnumber = {6}, \tpages = {553–595}, \tauthor = {A Arsenlis and W Cai and M Tang and M Rhee and T Oppelstrup and G Hommes and T G Pierce and V V Bulatov}, \ttitle = {Enabling strain hardening simulations with dislocation dynamics}, \tjournal = {Modelling and Simulation in Materials Science and Engineering}, \tabstract = {Numerical algorithms for discrete dislocation dynamics simulations are investigated for the purpose of enabling strain hardening simulations of single crystals on massively parallel computers. The algorithms investigated include the calculation of forces, the equations of motion, time integration, adaptive mesh refinement, the treatment of dislocation core reactions and the dynamic distribution of data and work on parallel computers. A simulation integrating all these algorithmic elements using the Parallel Dislocation Simulator (ParaDiS) code is performed to understand their behaviour in concert and to evaluate the overall numerical performance of dislocation dynamics simulations and their ability to accumulate percent of plastic strain.} }\n\n\n\n\n\n","category":"method"},{"location":"#DDD.calcSelfForce-Tuple{DDD.DislocationP,DDD.MaterialP,DislocationNetwork}","page":"Index","title":"DDD.calcSelfForce","text":"function calcSelfForce(\n    dlnParams::DislocationP,\n    matParams::MaterialP,\n    network::DislocationNetwork,\n)\n\nCalculates the self-interaction force felt by two nodes in a segment. Naturally the forces are equal and opposite to each other.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.checkNetwork-Tuple{DislocationNetwork}","page":"Index","title":"DDD.checkNetwork","text":"checkNetwork(network::DislocationNetwork)\n\nChecks the validity of the dislocation network. It ensures the following conditions are met by the member variables of network:\n\nconnectivity and links have the same number of non-zero entries;\nall entries in bVec are non-zero;\nonly the trailing columns of connectivity are zeros;\nconsistency between connectivity and links;\nbVec is conserved among connected nodes;\nentries in links are unique;\nconsistency betwen connectivity and linksConnect\n\n\n\n\n\n","category":"method"},{"location":"#DDD.compStruct-Tuple{Any,Any}","page":"Index","title":"DDD.compStruct","text":"compStruct(arg1, arg2; verbose::Bool=false)\n\nFunction that compares values of the fields of two variables arg1 and arg2 with the same structure. If verbose = true, it will print which fields are different from each other.\n\nExamples\n\njulia> struct MyStruct1; x; end\njulia> test1 = MyStruct1(1)\nMyStruct1(1)\njulia> test2 = MyStruct1(5)\nMyStruct1(5)\njulia> compStruct(test1, test2; verbose = true)\nStructures differ in field: x.\nfalse\njulia> compStruct(1, 1; verbose = true)\ntrue\njulia> compStruct(1, [1]; verbose = true)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#DDD.extAngle-Tuple{Int64}","page":"Index","title":"DDD.extAngle","text":"extAngle(n::Int64)\n\nCalculates the exterior angle of a regular polygon with n sides.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.intAngle-Tuple{Int64}","page":"Index","title":"DDD.intAngle","text":"intAngle(n::Int64)\n\nCalculates the interior angle of a regular polygon with n sides.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.load-Tuple{AbstractString}","page":"Index","title":"DDD.load","text":"load(filename::AbstractString)\n\nWrapper for JSON.parsefile(filename).\n\n\n\n\n\n","category":"method"},{"location":"#DDD.loadDislocationLoop-Tuple{Dict{T1,T2} where T2 where T1,SlipSystem}","page":"Index","title":"DDD.loadDislocationLoop","text":"function loadDislocationLoop(\n    dict::Dict{T1, T2} where {T1, T2},\n    slipSystem::SlipSystem,\n)\n\nLoads initial dislocation structure out of a dictionary loaded from a JSON file. Returns a variable of type DislocationLoop.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.loadDislocationP-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"Index","title":"DDD.loadDislocationP","text":"loadDislocationP(dict::Dict{T1, T2}) where {T1, T2}\n\nLoads dislocation parameters out of a dictionary loaded from a JSON file. Returns a variable of type DislocationP.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.loadIntegrationP-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"Index","title":"DDD.loadIntegrationP","text":"loadIntegrationP(dict::Dict{T1, T2}) where {T1, T2}\n\nLoads integration parameters out of a dictionary loaded from a JSON file. Returns a variable of type IntegrationP.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.loadMaterialP-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"Index","title":"DDD.loadMaterialP","text":"loadMaterialP(dict::Dict{T1, T2}) where {T1, T2}\n\nLoads material parameters out of a dictionary loaded from a JSON file. Returns a variable of type MaterialP.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.loadNetwork-Tuple{AbstractString}","page":"Index","title":"DDD.loadNetwork","text":"loadNetwork(fileDislocationNetwork::AbstractString)\n\nLoads a dislocation network from a JSON file. Returns a DislocationNetwork.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.loadParams-NTuple{5,AbstractString}","page":"Index","title":"DDD.loadParams","text":"loadParams(\n    fileDislocationP::AbstractString,\n    fileMaterialP::AbstractString,\n    fileIntegrationP::AbstractString,\n    fileSlipSystem::AbstractString,\n    fileDislocationLoop::AbstractString,\n)\n\nLoads simulation parameters out of a dictionary loaded from a JSON file. Returns a tuple of variable types (DislocationP, MaterialP, IntegrationP, SlipSystem, DislocationLoop) or vectors of those types.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.loadSlipSystem-Union{Tuple{Dict{T1,T2}}, Tuple{T2}, Tuple{T1}} where T2 where T1","page":"Index","title":"DDD.loadSlipSystem","text":"loadSlipSystem(dict::Dict{T1, T2}) where {T1, T2}\n\nLoads slip systems out of a dictionary loaded from a JSON file. Returns a variable of type SlipSystem.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.loopDistribution-Tuple{Zeros,Integer,Vararg{Any,N} where N}","page":"Index","title":"DDD.loopDistribution","text":"loopDistribution(dist<:AbstractDistribution, n::Integer, args...; kw...)\n\nReturns n points according to the concrete subtype of AbstractDistribution given. Overload this function with new concrete subtypes and custom distributions. This and limits! are used in translatePoints to distribute dislocations in the simulation domain.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.makeNetwork","page":"Index","title":"DDD.makeNetwork","text":"makeNetwork(\n    sources::Union{\n            DislocationLoop,\n            AbstractVector{<:DislocationLoop}\n        }, # Dislocation structures.\n    maxConnect::Integer = 4,\n    memBuffer::Integer = 10, # Buffer for memory allocation. The code will allocate the total number of nodes times `memBuffer` to reduce dynamic memory allocation during runtime.\n    args...;\n    checkConsistency::Bool = false, # Check the consistency of the network.\n    kw...,\n)\n\nConstructor for DislocationNetwork, see makeNetwork! for in-place version.\n\n\n\n\n\n","category":"function"},{"location":"#DDD.makeNetwork!","page":"Index","title":"DDD.makeNetwork!","text":"makeNetwork!(\n    network::DislocationNetwork,\n    sources::Union{\n        DislocationLoop,\n        AbstractVector{<:DislocationLoop}\n    },\n    maxConnect::Integer = 4,\n    args...;\n    checkConsistency::Bool = false,\n    kw...,\n)\n\nIn-place constructor for DislocationNetwork, see makeNetwork for constructor.\n\n\n\n\n\n","category":"function"},{"location":"#DDD.makeTypeDict-Tuple{DataType}","page":"Index","title":"DDD.makeTypeDict","text":"function makeTypeDict(valType::DataType)\n\nInputs contain strings that correspond to DDD data types. This function atuomatically creates a dictionary for all concrete subtypes of a given valType.\n\nExamples\n\njulia> abstract type MyAbstractType end\njulia> struct MyStruct1 <: MyAbstractType end\njulia> struct MyStruct2 <: MyAbstractType end\njulia> makeTypeDict(MyAbstractType)\nDict{String,Any} with 4 entries:\n  \"DDD.MyStruct1()\" => MyStruct1()\n  \"DDD.MyStruct2()\" => MyStruct2()\n  \"MyStruct1()\"     => MyStruct1()\n  \"MyStruct2()\"     => MyStruct2()\n\n\n\n\n\n","category":"method"},{"location":"#DDD.rot3D-Tuple{AbstractArray{#s13,1} where #s13<:Real,AbstractArray{#s12,1} where #s12<:Real,AbstractArray{#s39,1} where #s39<:Real,Real}","page":"Index","title":"DDD.rot3D","text":"rot3D(xyz::Vector{<:Real}, uvw::Vector{<:Real}, abc::Vector{<:Real},\n    θ::Real)\n\nRotate point xyz about the line with direction vector uvw that crosses the point abc by the angle θ. Further details found here.\n\nExamples\n\njulia> rot3D([1;1;1],[1;0;0],[0;0;0],π/2)\n3-element Array{Float64,1}:\n  1.0\n -0.9999999999999999\n  1.0\njulia> rot3D([1;1;1],[1;0;0],[0;0;0],-π/2)\n3-element Array{Float64,1}:\n1.0\n1.0\n-0.9999999999999999\njulia> rot3D([1;1;1],[1;0;0],[0;0;0],π)\n3-element Array{Float64,1}:\n  1.0\n -1.0000000000000002\n -0.9999999999999999\n\n\n\n\n\n","category":"method"},{"location":"#DDD.save-Tuple{AbstractString,Vararg{Any,N} where N}","page":"Index","title":"DDD.save","text":"save(filename::AbstractString, args...; mode::AbstractString = \"w\")\n\nWrapper for JSON.print to a file, args are the variables or structures you want to save.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.shapeFunction-Tuple{LinearQuadrangle3D,Float64,Float64,Float64}","page":"Index","title":"DDD.shapeFunction","text":"shapeFunction(\n    shape<:AbstractShapeFunction,\n    x::Union{Float64, AbstractVector{<:Float64}},\n    y::Union{Float64, AbstractVector{<:Float64}},\n    z::Union{Float64, AbstractVector{<:Float64}}\n\nReturns the shape functions of type typeof(shape) <: AbstractShapeFunction. If x,y,z are floats returns a vector of length N, different shape functons have different numbers of nodes. If given vectors, returns an array of size (N, length(x)).\n\nnote: Note\nAll coordinate vectors must be of equal length.\n\nshapeFunctionDeriv are the 1st order derivatives of the shape functions.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.shapeFunctionDeriv-Tuple{LinearQuadrangle3D,Float64,Float64,Float64}","page":"Index","title":"DDD.shapeFunctionDeriv","text":"shapeFunctionDeriv(\n    shape<:AbstractShapeFunction,\n    x::Union{Float64, AbstractVector{<:Float64}},\n    y::Union{Float64, AbstractVector{<:Float64}},\n    z::Union{Float64, AbstractVector{<:Float64}}\n\nReturns the first order derivative of the shape functions, shapeFunction, of type typeof(shape) <: AbstractShapeFunction. If x,y,z are floats returns a 2D array of size (N, 3). If given vectors, returns a 3D array of size (N, 3, length(x)).\n\nnote: Note\nAll coordinate vectors must be of equal length.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.AbstractCrystalStruct","page":"Index","title":"DDD.AbstractCrystalStruct","text":"abstract type AbstractCrystalStruct end\nstruct BCC <: AbstractCrystalStruct end\nstruct FCC <: AbstractCrystalStruct end\nstruct HCP <: AbstractCrystalStruct end\n\nCrystal structures.\n\n\n\n\n\n","category":"type"},{"location":"#DDD.AbstractDlnSeg","page":"Index","title":"DDD.AbstractDlnSeg","text":"There are different types of segments. Edge segments are orthogonal to the Burgers vector; screw segments are parallel to the Burgers vector; mixed segments are anything in between. Segment type can be easily inferred during runtime. These are mainly used for multiple dispatch purposes.\n\nabstract type AbstractDlnSeg end\nstruct segNone <: AbstractDlnSeg end    # Undefined segment.\nstruct segEdge <: AbstractDlnSeg end    # Edge segment.\nstruct segEdgeN <: AbstractDlnSeg end   # Edge segment parallel to slip plane.\nstruct segScrew <: AbstractDlnSeg end   # Screw segment.\nstruct segMixed <: AbstractDlnSeg end   # Mixed segment.\n\n\n\n\n\n","category":"type"},{"location":"#DDD.AbstractIntegrator","page":"Index","title":"DDD.AbstractIntegrator","text":"abstract type AbstractIntegrator end\nstruct CustomTrapezoid <:AbstractIntegrator end\n\nIntegrator types.\n\n\n\n\n\n","category":"type"},{"location":"#DDD.AbstractMesh","page":"Index","title":"DDD.AbstractMesh","text":"abstract type AbstractMesh end\n\nAbstract mesh type.\n\n\n\n\n\n","category":"type"},{"location":"#DDD.AbstractMobility","page":"Index","title":"DDD.AbstractMobility","text":"abstract type AbstractMobility end\nstruct BCC <: AbstractMobility end\nstruct FCC <: AbstractMobility end\nstruct HCP <: AbstractMobility end\n\nMobility functions.\n\n\n\n\n\n","category":"type"},{"location":"#DDD.AbstractShapeFunction","page":"Index","title":"DDD.AbstractShapeFunction","text":"abstract type AbstractShapeFunction end\nabstract type AbstractShapeFunction3D <: AbstractShapeFunction end\nabstract type AbstractShapeFunction2D <: AbstractShapeFunction end\nstruct LinearQuadrangle3D <:AbstractShapeFunction3D end\nstruct LinearQuadrangle2D <:AbstractShapeFunction2D end\n\nAbstract types for different shape functions.\n\n\n\n\n\n","category":"type"},{"location":"#DDD.DislocationP","page":"Index","title":"DDD.DislocationP","text":"DislocationP{\n    T1 <: Float64,\n    T2 <: Int64,\n    T3 <: Bool,\n    T4 <: AbstractMobility,\n}\n    # Size.\n    coreRad::T1     # Core radius.\n    coreRadMag::T1  # Magnitude of core Radius.\n    # Connectivity.\n    minSegLen::T1       # Minimum line length.\n    maxSegLen::T1       # Maximum line length.\n    minArea::T1         # Minimum area for remeshing.\n    maxArea::T1         # Maximum area for remeshing.\n    maxConnect::T2      # Maximum number of connections to a node.\n    remesh::T3          # Flag for remeshing.\n    collision::T3       # Flag for collision handling.\n    separation::T3      # Flag for separation handling.\n    virtualRemesh::T3   # Flag for virtual remeshing.\n    # Mobility.\n    edgeDrag::T1    # Drag coefficient edge dislocation.\n    screwDrag::T1   # Drag coefficient screw dislocation.\n    climbDrag::T1   # Drag coefficient climb.\n    lineDrag::T1    # Drag coefficient line.\n    mobility::T4    # Mobility law.\n\nDislocation parameters structure. See AbstractMobility for more details.\n\n\n\n\n\n","category":"type"},{"location":"#DDD.IntegrationP","page":"Index","title":"DDD.IntegrationP","text":"IntegrationP{\n    T1 <: Float64,\n    T2 <: AbstractIntegrator,\n    T3 <: Int64,\n}\n    dt::T1\n    tmin::T1\n    tmax::T1\n    method::T2\n    abstol::T1\n    reltol::T1\n    time::T1\n    step::T3\n\nThis structure contains the integration parameters for the simulation.\n\n\n\n\n\n","category":"type"},{"location":"#DDD.MaterialP","page":"Index","title":"DDD.MaterialP","text":"MaterialP{T1 <: Float64, T2 <: AbstractCrystalStruct}\n    μ::T1\n    μMag::T1\n    ν::T1\n    E::T1\n    crystalStruct::T2\n\n\n\n\n\n","category":"type"},{"location":"#DDD.coordIdx-Union{Tuple{N}, Tuple{DislocationNetwork,Union{Integer, AbstractArray{#s69,N} where #s69<:Integer}}} where N","page":"Index","title":"DDD.coordIdx","text":"coordIdx(network::DislocationNetwork,\n    index::Union{Integer,AbstractArray{<:Integer, N}) where {N}\n\nGet coordinates for the node(s) that with the index or vector of indices provided.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.coordLbl-Tuple{DislocationNetwork,Integer}","page":"Index","title":"DDD.coordLbl","text":"Related functions: idxLabel\n\ncoordLbl(network::DislocationNetwork, label::Integer)\n\nGet coordinates for the nodes with a given label (node type).\n\n\n\n\n\n","category":"method"},{"location":"#DDD.dataCond-Tuple{DislocationNetwork,Symbol,Real}","page":"Index","title":"DDD.dataCond","text":"Related functions: idxCond\n\ndataCond(network::DislocationNetwork, dataField::Symbol, val::Real;\n    condition::Function = ==)\n\nGet the data whose dataField, (:links, :bVec, :slipPlane, :coord, :label, :numNode, :numSeg), meets the condition(dataField, val). If dataField is multidimensional it will use CartesianIndex to find it.\n\ndataCond(network::DislocationNetwork, dataField::Symbol, idxComp::Integer,\n    val::Real; condition::Function = ==)\n\nGet the data whose dataField, meets the condition(dataField[:,idxComp], val). It errors if the fieldname provided does not have a column idxComp.\n\ndataCond(network::DislocationNetwork, dataField::Symbol, condField::Symbol,\n    val::Real; condition::Function = ==)\n\nGet the data from dataField that corresponds to the condField (from the same pool as dataField) that meets the condition(condField, val). If condField is multidimensional it will use CartesianIndex in its search. dataField and condField must have the same number of rows.\n\ndataCond(network::DislocationNetwork, dataField::Symbol, condField::Symbol,\n    idxComp::Integer, val::Real; condition::Function = ==)\n\nGet the data from dataField that corresponds to the condField that meets the condition(condField[:, idxComp], val). dataField and condField must have the same number of rows.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.hatStress-Tuple{DDD.RegularCuboidMesh,DDD.DislocationFEMCorrective,AbstractArray{#s68,N} where #s68<:Float64 where N}","page":"Index","title":"DDD.hatStress","text":"\n\nCalculate the reaction from a dislocation.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.idxCond-Tuple{DislocationNetwork,Symbol,Function,Vararg{Any,N} where N}","page":"Index","title":"DDD.idxCond","text":"Related functions: dataCond\n\nidxCond(network::DislocationNetwork, fieldname::Symbol,\n    args...; condition::Function)\n\nFind index/indices whose fieldname meets the condition(fieldname, args...) where condition can be any function that uses fieldname and args to make a comparison.\n\nidxCond(data::Union{\n        AbstractArray{<:Real,N1},\n        AbstractArray{<:nodeType, {N2}}\n    },\n    val::Real; condition::Function = ==) where {N1,N2}\n\nFind index/indices of data that meet the condition(data, val).\n\nidxCond(network::DislocationNetwork, fieldname::Symbol, val::Real;\n    condition::Function = ==)\n\nFind index/indices of node whose fieldname, (:links, :bVec, :slipPlane, :coord, :label, :numNode, :numSeg), meets condition(fieldname, val). If fieldName is multidimensional it will return CartesianIndex.\n\nidxCond(network::DislocationNetwork, fieldname::Symbol, idxComp::Integer,\n    val::Real; condition::Function = ==)\n\nFind index/indices of node whose fieldname meets condition(fieldname[:, idxComp], val). It errors if the fieldname provided does not have a column idxComp.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.idxLabel-Tuple{DislocationNetwork,Integer}","page":"Index","title":"DDD.idxLabel","text":"Related functions: coordLbl\n\nidxLabel(network::DislocationNetwork, label::Integer; condition::Function = ==)\n\nFind indices for dislocations whose label meets condition(x, label).\n\n\n\n\n\n","category":"method"},{"location":"#DDD.inclusiveComparison-Tuple{Any,Vararg{Any,N} where N}","page":"Index","title":"DDD.inclusiveComparison","text":"inclusiveComparison(data, args...)\n\nCompare data to a tuple, return true if it is equal to any arg, false if it is not equal to any.\n\nExamples\n\njulia> inclusiveComparison(\"f\", 1,4,5,\"f\")\ntrue\njulia> inclusiveComparison(23.246, 1.5, 4, 5, \"f\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#DDD.limits!-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s66,N1} where #s66<:Float64,Float64,AbstractArray{#s65,N2} where #s65<:Float64,Float64}} where N2 where N1","page":"Index","title":"DDD.limits!","text":"limits!(\n    lims::AbstractArray{<:Float64, N1},\n    segLen::Float64,\n    range::AbstractArray{<:Float64, N2},\n    buffer::Float64,\n) where {N1, N2}\n\nCalculate the spatial limits a dislocation will occupy. This and loopDistribution are used in translatePoints to distribute dislocations in the simulation domain.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.makeConnect!-Tuple{DislocationNetwork}","page":"Index","title":"DDD.makeConnect!","text":"makeConnect!(network::DislocationNetwork)\n\nCreates connectivity and linksConnect matrices in-place. connectivity contains the number of other other nodes each node is connected to, up to maxConnect other nodes. It also contains the segments in which it's involved. linksConnect is the running total of the number of other nodes each node is connected to, will probably be deleted in the future. This is called from makeNetwork and makeNetwork!.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.makeInstanceDict-Tuple{DataType}","page":"Index","title":"DDD.makeInstanceDict","text":"makeInstanceDict(valType::DataType)\n\nMake a dictionary of enumerated variable instances. Helps in translating JSON files.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.makeLoop-Union{Tuple{T8}, Tuple{T7}, Tuple{T6}, Tuple{T5}, Tuple{T4}, Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{T1,T2,T2,T2,T3,T2,T4,T4,T5,T6,T7,T8}} where T8<:AbstractDistribution where T7<:(AbstractArray{#s61,N} where #s61<:Float64 where N) where T6<:Float64 where T5<:Array{nodeType,1} where T4<:(AbstractArray{#s62,N} where #s62<:Float64 where N) where T3<:Union{Float64, AbstractArray{#s63,N} where #s63<:Float64 where N} where T2<:Int64 where T1<:AbstractDlnStr","page":"Index","title":"DDD.makeLoop","text":"makeLoop(\n    loopType::T1,\n    numSides::T2,\n    nodeSide::T2,\n    numLoops::T2,\n    segLen::T3,\n    slipSystem::T2,\n    _slipPlane::T4,\n    _bVec::T4,\n    label::T5,\n    buffer::T6,\n    range::T7,\n    dist::T8,\n) where {\n    T1 <: AbstractDlnStr,\n    T2 <: Int64,\n    T3 <: Union{T where {T <: Float64}, AbstractArray{<:Float64, N} where {N}},\n    T4 <: AbstractArray{<:Float64, N} where {N},\n    T5 <: Vector{nodeType},\n    T6 <: Float64,\n    T7 <: AbstractArray{<:Float64, N} where {N},\n    T8 <: AbstractDistribution,\n}\n\nConstructor function for DislocationLoop. See AbstractDlnStr, AbstractDlnSeg, nodeType, AbstractDistribution for further details.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.makeSegment-Union{Tuple{T}, Tuple{DDD.segEdge,Array{T,1},Array{T,1}}} where T<:Float64","page":"Index","title":"DDD.makeSegment","text":"makeSegment(type::AbstractDlnSeg, slipPlane::Vector{T}, bVec::Vector{T})\n    where {T<:Float64}\n\nMake signle segment depending on the segment type, see AbstractDlnSeg.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.pkForce-Tuple{DDD.DislocationFEMCorrective,DDD.RegularCuboidMesh,AbstractArray{#s69,N} where #s69<:Float64 where N}","page":"Index","title":"DDD.pkForce","text":"\n\nCalculate the Peach-Koehler force on segments.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.subTypeTree-Tuple{Any}","page":"Index","title":"DDD.subTypeTree","text":"subTypeTree(t, level = 1, dict = Dict(); cutoff = 0)\n\nCreate subtype dictionary. . Adapted from https://github.com/JuliaLang/julia/issues/24741\n\n\n\n\n\n","category":"method"},{"location":"#DDD.translateEnum-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{DataType,Dict{T1,T2},T3}} where T3 where T2 where T1","page":"Index","title":"DDD.translateEnum","text":"translateEnum(\n    valType::DataType,\n    dict::Dict{T1, T2},\n    key::T3,\n) where {T1, T2, T3}\n\nTranslates the string name of enumerated types to the actual Julia type.\n\n\n\n\n\n","category":"method"},{"location":"#DDD.translatePoints-Union{Tuple{N2}, Tuple{N1}, Tuple{AbstractArray{#s65,N1} where #s65<:Float64,AbstractArray{#s64,N1} where #s64<:Float64,AbstractArray{#s63,N2} where #s63<:Float64}} where N2 where N1","page":"Index","title":"DDD.translatePoints","text":"function translatePoints(\n    coord::AbstractArray{<:Float64, N1},\n    lims::AbstractArray{<:Float64, N1},\n    disp::AbstractArray{<:Float64, N2},\n) where {N1, N2}\n\nTranslate dislocation node coordinates coord inside the spatial bounds of lims (calculated in limits!) according to the displacement disp (calculated in loopDistribution). Used to distribute sources inside a domain in makeNetwork and makeNetwork!.\n\n\n\n\n\n","category":"method"},{"location":"#JSON.Writer.lower-Union{Tuple{T}, Tuple{T}} where T<:Union{DDD.AbstractCrystalStruct, AbstractDistribution, DDD.AbstractDlnSeg, AbstractDlnStr, DDD.AbstractIntegrator, DDD.AbstractMobility}","page":"Index","title":"JSON.Writer.lower","text":"JSON.lower(\n    t::T,\n) where {\n    T <: Union{\n        AbstractCrystalStruct,\n        AbstractMobility,\n        AbstractIntegrator,\n        AbstractDlnSeg,\n        AbstractDlnStr,\n        AbstractDistribution,\n    },\n} = string(t)\n\nJSON.lower(t::nodeType) = Int(t)\n\nExtensions to JSON.lower for custom types. Allows these variables to be serialised properly.\n\n\n\n\n\n","category":"method"},{"location":"io/#IO-1","page":"IO","title":"IO","text":"","category":"section"},{"location":"io/#Input-1","page":"IO","title":"Input","text":"","category":"section"},{"location":"io/#Output-1","page":"IO","title":"Output","text":"","category":"section"},{"location":"types/#Types-1","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/#Primitive-Types-1","page":"Types","title":"Primitive Types","text":"","category":"section"},{"location":"types/#Composite-Types-1","page":"Types","title":"Composite Types","text":"","category":"section"}]
}
